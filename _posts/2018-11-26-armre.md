---
layout: post
title:  "ARM逆向"
date:   2018/11/26 23:00:00
categories: ARM逆向
tag: 逆向
---

# 作用域

## 局部变量

放在栈中，已初始化的通过mov或ldr给寄存器，再str到对应的位置。因为arm中都是在函数开头一次抬栈的，故不一定需要像x86中那样使用ebp来访问局部变量。gcc还是使用了R11(FP)来访问局部变量。另外，已初始化的结构体gcc在armeabi-v7a版本是存储在了.rodata节中，

## 静态局部变量

已初始化的存放在.data节中。未初始化的存放在.bss节中，并且通过另一个放在.bss值按位判断是否是第一次访问。

## 全局变量

# 函数

## 参数

* 4个参数及以下：从左到右通过R0~R3寄存器传参
* 大于4个参数：前4个参数同上，后面的参数从右到左入栈传参
* 浮点数作参数：同上
* 大于4字节的参数：将其拆分为多个4字节参数传入，例如1个`long long`参数就通过R0R1传入，1个100个int组成的结构体前4个int通过寄存器，后96个int使用memcpy复制到栈上传递。
* 结构体：armev7a已初始化的结构体数据存储在.rodata节中，连续的。多个其他参数则是直接使用mov指令或ldr伪指令。

## 返回值

* 小于等于4个字节：通过R0寄存器返回
* longlong：通过R0R1返回
* double：通过R0R1返回
* 大于4个字节的结构体：引用返回。即将外部申请的空间作为第一个参数传入函数内部，函数内部将返回值放入传入的地址处。