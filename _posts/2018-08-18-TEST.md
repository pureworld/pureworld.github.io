---
layout: post
title:  "四则运算"
date:   2018/8/18 10:50:51 
categories: 逆向工程
tag: 四则运算
---

# 四则运算 #
## 一、加减乘 ##
1. 加减：使用add，sub指令

2. 乘法：因为32位无符号乘法指令mul和单操作数的有符号乘法指令imul的结果为64位edx.eax，而C语言中的乘法结果仍然为32位，故不管是有符号数相乘，还是无符号数相乘，都使用两操作数或三操作数的有符号乘法指令imul或者移位指令shl。
     1. VS2013 Debug版
         1. 变量m*非2的n次幂正数c：使用三操作数的imul         
                imul reg, m, c
                push reg
         2. 变量m*2的n次幂正数：使用shl
                mov reg, m
                shl reg, n
                push reg
         3. 变量m*变量n：使用两操作数的imul
                mov reg, m
                imul reg, n
                push reg
         4. 变量m*负数：
               将负号提到变量m前，之后与正数相同，即先
                mov reg, m
                neg reg
     2. VS2013 Release版
           1. lea指令优化
                变量m*常量c的某些情况下，例如c=3时，编译器会使用lea指令优化。
                    lea eax, [eax + eax * 2] ; eax = eax * 3
                    lea eax, [eax + eax * 4] ; eax = eax * 5
                    lea eax, [eax + eax * 2]
                    add eax, eax                  ; eax = eax * 6
                    lea ecx, [eax * 8]
                    sub ecx, eax                   ; ecx = eax * 7
                    lea eax, [eax + eax * 8] ; eax = eax * 9
                    lea eax, [eax + eax * 4]
                    add eax, eax                  ; eax = eax * 10
                    lea edx, [eax + eax * 4]
                    lea eax, [eax + edx * 2] ; eax = eax * 11 gcc, imul vs
                    lea eax, [eax + eax * 2]
                    shl eax, 2                        ; eax = eax * 12
                    lea     edx, [eax+eax*2]
                    lea     eax, [eax+edx*4] ; eax = eax * 13 gcc, imul vs
                    lea ecx, [eax * 8]
                    seb ecx, eax
                    add ecx, ecx                   ; eax = eax * 14 vs, gcc imul
                    ......
           2. 其他与Debug版相同
     3. gcc：同VS Release
     4. Clang：同VS Debug

## 二、除法 ##
除法：当被除数、除数中有一个为无符号数时，那么便按无符号数计算
   1. 无符号变量m/无符号变量n
           mov eax, m
           xor edx, edx
           div n
           push eax
   2. 有符号变量m/有符号变量n
           mov eax, m
           cdq
           idiv n
           push eax
   3. 无符号变量m/常量2的n次幂
           mov reg, m
           shr reg, n
           push reg
   4. 有符号变量m/常量2的n次幂：当m>=0时，直接算术右移n位；当m<0时，m/2^n向0取整 = m/2^n向上取整 = (m+2^n-1)/2^n向下取整 = (m+2^n-1)>>n。作无分支优化后，VS版如下：
           mov eax, m
           cdq
           and edx, 2^n-1
           add eax, edx
           sar eax, n
           push eax
    gcc版如下：
           mov reg1, m
           mov reg2, reg1
           sar reg2, 31
           and reg2, 2^n-1
           add reg2, reg1
           sar reg2, 3
           push reg2
     clang版使用idiv
   5. 有符号变量m/常量负2的n次幂：在4的基础上多一句neg指令即可
   6. 无符号变量m/常量非2的n次幂c
        VS Debug版，clang版使用div。
        VS Release版和gcc版时，M不需要进位时：
            mov eax, M ; m/c=m*M/2^, M=2^n/c，n值编译器编译时算出，最小为32，算法详见第9条
            mul m
            shr edx, n - 32 ;
            push edx ; 还原时，c = 2^n/M 取上整
        M需要进位时：（例如c = 7）
            mov reg, m
            mov eax, M
            mul reg
            sub reg, edx
            shr reg, 1
            add reg, edx
            shr reg, 2
            push reg ; 还原时，c = 2^(32+1+2)/(M+2^32) 取上整
   7. 有符号变量m/常量非2的n次幂c
        VS Debug版，clang版使用idiv。
        VS Release版和gcc版时，当M>0时：
             mov eax, M
             imul m
             sar edx, n - 32
             mov reg, edx ;1
             shr reg, 31  ;2
             add reg, edx ;3这3条指令作用为下整转上整，在gcc中，起同样作用的是以下两条指令：
             (sar eax, 31
             sub edx, eax)
             push reg ; 还原时，c = 2^n/M
        当M<0时：
             mov eax, M
             imul m
             add edx, m  ; 调整
             sar edx, n -32
             mov reg, edx
             shr reg, 31
             add reg , edx
             push reg ; 还原时，c = 2^n/M
   8. 有符号变量m/常量负非2的n次幂c
        VS Debug版，clang版使用idiv。
        VS Release版和gcc版时，当M<0时：
             mov eax, M
             imul m
             sar edx, n - 32
             mov reg, edx
             shr reg, 31
             add reg, edx
             push reg ; 还原时，|c| = 2^n/(~M+1)
        当M>0时：
             mov eax, M
             imul m
             sub edx, m  ; 调整
             sar edx, n - 32
             mov reg, edx
             shr reg, 31
             add reg, edx
             push reg ; 还原时，|c| = 2^n/(~M+1)
         > 7、8总结，有符号除法的还原：
         > 当M>0时，无调整，则除数为正；有减调整，则除数为负；当M<0时，无调整，则除数为负；有加调整，则除数为正。除数为正时，还原方法为c = 2^n/M；除数为负时，还原方法为|c| = 2^n/(~M+1)。

   9. Magic Number的获取方法
        VC++6.0的获取方法：
   10. 常用除数的Magic Number表

# 取余 #
1. 变量m % 变量n ： 直接使用div、idiv，取edx中的值。
2. 无符号数m % 常量2的n次幂
    VS Debug版使用div取edx值
    VS Release版、gcc版、clang版优化后为：
       mov reg, m
       and reg, 2^n-1
       push reg
3. 无符号数m % 常量非2的n次幂c
    VS Debug版、clang版使用div取edx值
    VS Release版、gcc版：使用r = a - q * b公式，q是商由优化后的除法算出，b是除数，a是被除数
       mov reg1, m
       div c
       mov reg2, eax ; 此处仅代指，实际使用的是除法的优化算法
       mul reg3, reg2 ; 此处仅代指，实际使用的是乘法的优化算法
       sub reg1, reg3
       push reg1
4. 有符号数m % 常量2的n次幂
    clang版使用div取edx值
    VS Debug版、VS Release版正数使用jns优化：
            mov reg, m
            and reg, (2^n-1)|80000000h
            jns label
            dec reg
            or reg, ~(2^n-1)|80000000h
            inc reg
        label:
    负数优化：
        mov eax, m
        cdq
        xor eax, edx
        sub eax, edx
        and eax, 2^n-1
        xor eax, edx
        sub eax, edx
        push eax
    gcc版正负优化相同：
        mov eax, m
        cdq
        shr edx, 32-n
        add eax, edx
        and eax, 2^n-1
        sub eax, edx
        push eax
5. 有符号数m % 常量非2的n次幂c
      VS Debug、clang版使用idiv后取edx值
      VS Release、gcc版使用r = a - q * b公式优化

# 三目运算 #
1. 基础三目预算