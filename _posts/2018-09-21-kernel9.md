---
layout: post
title:  "Windows内核八、系统中断表"
date:   2018/09/21 23:00:00
categories: 内核
tag: IDT
---

# 中断与异常

80386把外部中断称为“中断”，把内部中断称为“异常”，最多处理256种中断或异常。80386有两根引脚INTR和NMI接收外部中断请求信号。INTR接收可屏蔽中断请求，NMI接收不可屏蔽中断请求。标志寄存器EFLAGS的IF标志决定是否屏蔽可屏蔽中断请求。

根据引起异常的程序是否可被恢复和恢复点的不同，把异常进一步分类为故障(Fault)、陷阱(Trap)和中止(Abort)。

80386识别的异常

向量号 | 异常名称 | 异常类型 | 出错代码 | 相关指令
0 | 除法出错 | 故障 | 无 | DIV,IDIV
1 | 调试异常 | 故障/陷阱 | 无 | 任何指令
3 | 单字节INT3 | 陷阱 | 无 | INT3
4 | 溢出 | 陷阱 | 无 | INT0
5 | 边界检查 | 故障 | 无 | BOUNT
6 | 非法操作码 | 故障 | 无 | 非法指令编码或操作数
7 | 设备不可用 | 故障 | 无 | 浮点指令或WAIT
8 | 双重故障 | 终止 | 有 | 任何之灵
9 | 协处理器段越界 | 终止 | 无 | 访问浮点寄存器存取指令
A | 无效TSS异常 | 故障 | 有 | JMP,CALL,IRET或中断
B | 段不存在 | 故障 | 有 | 装在段寄存器的指令
C | 堆栈段异常 | 故障 | 有 | 装在SS寄存器的任何指令，对SS寻址的段访问的任何指令
D | 通用保护异常 | 故障 | 有 |任何特权指令，任何访问存储器的指令
E | 页异常 | 故障 | 有 |任何访问存储器的指令
10 | 协处理器出错 | 故障 | 无 | 浮点指令或WAIT
11-FF | 软中断 | 陷阱 | 无 | INT n

# 中断描述符表IDT

在响应中断或者处理异常时，80386根据中断向量号转到对应的处理程序。在保护模式下，80386使用中断向量号作为中断描述符表IDT中描述符的索引。

中断描述符表寄存器IDTR指示IDT在内存中的位置。由于80386只识别256个中断向量号，所以IDT的最大长度是2K。

中断描述符表IDT所含的描述符只能是中断门、陷阱门和任务门。

![image]({{ '/styles/images/kernel/35.png' | prepend: site.baseurl }})

## 中断门或陷阱门的转移

1. 若选择子为空，则产生通用保护故障；
2. 取对应的描述符；
3. 若非存储段描述符，则产生通用保护故障；
4. 若非一致代码段且DPL<CPL且段存在，则切换到内层堆栈；
5. 调整RPL=0；
6. 把描述符装入CS；
7. 若入口偏移越界，则产生通用保护异常；
8. EFLAGS入栈；
9. CS入栈；
10. EIP入栈；
11. 使TF=0，NT=0；
12. 若为中断门，则使IF=0；
13. 若有出错码，则把出错码入栈；
14. 转入处理程序。

## 任务门的转移

如果中断向量号所指示的门描述符是任务门描述符，那么控制转移到一个作为独立的任务方式出现的处理程序。任务门中的选择子是指向描述对应处理程序任务的TSS段的选择子，即该选择子指示一个可用的286TSS或386TSS。通过任务门的转移与通过任务门到一个可用的386TSS的段间调用指令CALL的转移很相似，主要的区别是，对于提供出错码的异常处理，在完成任务切换之后，把出错码压入新任务的堆栈中(通过任务门进行转移时，返回地址和外层栈指针不压入新任务的堆栈)。 

## 处理后的返回

* 使用IRET指令返回
* NT位为1，表示是嵌套任务的返回。当前TSS中的链接字段保存有前一任务的TSS的选择子，取出该选择子进行任务切换就完成了返回。这种情形在由通过任务门转入的中断或异常处理程序返回时出现，因为在由中断门或陷阱门转入处理程序时，NT位已被清0。
* NT位为0，表示当前任务内的返回。这种情形在由通过中断门或陷阱门转入的中断或异常处理程序返回时出现。具体进行的操作包括：从堆栈顶弹出返回指针EIP及CS，然后弹出EFLAGS值。弹出的CS选择子的RPL字段，确定返回后的特权级。如果返回选择子的RPL与CPL相同，则不进行特权级改变。若RPL规定了一个外层特权级，则需要特权级改变，从内层堆栈中弹出外层堆栈的指针ESP及SS的值。

# 对IDT的Hook

如果我们修改IDT表，就可以使用自己的代码处理对应的异常。常见的应用：

1. Hook INT 3 ： 可实现反调试
2. Hook INT 0x93 ： 可实现监控键盘，但是因为这种方式需要自己获取并解析键盘码，还要换回去，过于繁琐，很少使用。

# Windows系统调用的方式

通过在OD中跟踪系统API的调用，会发现其使用`int 2e`指令进入0环，使用eax寄存器传递API编号，使用门描述符传递参数的个数，使用栈传递参数，另外需要注意的是fs寄存器的值需要自己保存和恢复。