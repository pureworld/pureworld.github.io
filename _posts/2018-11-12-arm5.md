---
layout: post
title:  "ARM汇编五、伪指令与注入"
date:   2018/11/12 23:00:00
categories: Android
tag: ARM
---

# 伪指令

在之前节的汇编编程中，感受到了ARM汇编的不便之处：1.立即数很大的限制；2.因为指令长度限制，与label相关的指令偏移都比较小，如果大了就需要自己结合PC来算。为了解决(部分？)这个问题，ARM汇编中提供了几个伪指令方便编程。这些伪指令在编译时会被等效的替换为一条或多条ARM指令。

## ADR和ADRL伪指令

ADR和ADRL伪指令将基于PC相对偏移的地址值或基于寄存器相对偏移的地址值读取到寄存器中。通常，ADR被一条ADD或SUB替换，ADRL被一条或两条ADD或SUB替换，若不能，则报错，编译失败。

指令格式：
    ```
    ADR{cond}   register, expr
    ADRL{cond}  register, expr
    ```
    ADR伪指令的地址表达式expr当地址值是字节对齐时其取值范围为-255~255，字对齐时其取值范围为-1020~1020；ADRL则更长一些， 分别是-64K~64K和-256K和256K。可惜的是，这两个伪指令仍然不能跨节使用。所以要使用全局常量或者变量时仍然要在代码区存储偏移，再通过PC计算。

## LDR伪指令

LDR伪指令用于加载32位的立即数或一个地址值到指令寄存器。该指令会被替换成一条合适的指令。如果可以使用MOV或MVN，则使用；否则将该常量放入文字池(就是代码区)，并使用一条程序相对偏移的LDR指令从文字池读出常量(会降低效率，所以追求效率还是自己分割成多条MOV/MVN指令吧)。

指令格式：
```
LDR{cond}   register, =[expr | label_expr]
```

为了与ARM指令的LDR区分，伪指令LDR的参数有“=”号。

## NOP伪指令

跟x86中的nop类似。会被替换为`mov r0, r0`指令。

# 混合编程

## 内嵌汇编
语法：
```
__asm__("instruction\n"
        "..."
        "instruction\n");
```

裸函数：在C/C++中，定义一个函数编译器就会加上默认的保存参数、返回值等操作，有时候我们需要一个纯汇编的函数，这时就需要在函数前加上`__attribute__((naked))`。

## C/C++调用汇编
## 汇编调用C/C++

.s文件与.c文件可同样使用，没有什么特别的。当然，如果是.cpp文件的话，还需要注意一下名称粉碎的问题，即加上`extern "C"`。

# Android远程注入

Android中没有Windows那么多的注入手法，就一个，使用`ptrace`调试函数。Windows写一个调试器需要各种API，而linux，就一个`ptrace`，当然了，使用这个需要root权限。

[详细代码](https://github.com/pureworld/AndroidInject)

## 简单的反调试

1. 使用ptrace的PTRACE_ME功能，这样如果有人附加的话，因为自己已经在被自己调试了，故会附加失败。如果对方是调试运行的话，PTRACE_ME会失败，通过判断这点，我们可以直接退出程序或者走些不一样的混淆流程。
2. 通过检查`/proc/pid/status`文件中的TraceId项，如果没有被调试值为0，不为0则说明被调试。
