---
layout: post
title:  "ARM汇编二、寻址方式和指令格式"
date:   2018/11/07 23:00:00
categories: Android
tag: ARM
---

# 寻址方式

寻址方式是根据指令中给出的地址码字段来实现寻找真实操作数地址的方式。ARM处理器具有9种基本寻址方式：(与x86不同的有两种，着重介绍)

* 寄存器寻址
* 立即寻址

    ARM汇编语言中使用#表示立即数，并且因为指令长度、格式(详见下节)的原因，不是每个立即数都可以直接使用的。例如在`mov reg, imm`这条指令中，imm就必须是8位立即数的循环右移2的倍数(4位，即最大为16*2)次。故如果想执行`mov r0, 0x12345678`这样的指令的话，只能分成4条指令：
    ```
    mov r0, 0x12000000
    add r0, r0, 0x00340000
    add r0, r0, 0x00005600
    add r0, r0, 0x00000078
    ```
    如果不想自己算的话，也可以定义一个`.word`放入0x12345678再通过地址访问即可，不过这样效率就会差一点。

* **寄存器移位寻址**

    当第2个操作数是寄存器移位方式时，第2个寄存器操作数在与第1个操作数结合之前，选择进行移位操作。这样子可以方便的进行数组下标运算，比x86比例因子寻址方便的是倍数不仅仅只能乘以8。例如：
    ```
    MOV R0, R2, LSL #3         @R2的值左移3位，结果放入R0
    ANDS R1, R1, R2, LSL R3    @R2的值左移R3位，然后结果与R1进行与操作结果放入R1
    ```


* 寄存器间接寻址
* 基址寻址

    这里介绍一下ARM汇编中的`!`操作，即回写。例如：
    ```
    STR R1,[R0,#-4]!    @先R0=R0-4(如果没有!就没有这一步操作，且下一步是R0-4的值)
                        @然后把R0的值保存到R1指令的存储单元
    ```

* **多寄存器寻址**

    如果在x86里要保存多个又不是全部寄存器环境，只能一条一条的写，而ARM则可以一条搞定16个寄存器的任何子集。例如：
    ```
    LDMIA R1!, {R2-R7, R12} @将R1指令的单元中的数据读出到R2~R7和R12中，R1自动加4
    ```

* 堆栈寻址

    这里介绍一下进出栈的两个概念。一个是：
        * 向上生长：向高地址方向生长，称为递增堆栈
        * 向下生长：向低地址方向生长，称为递减堆栈
    另一个是：
        * 满堆栈：堆栈指针指向最后压入的堆栈的有效数据项，即先抬栈再压入
        * 空堆栈：堆栈指针指向下一个待压入数据的空位置，即先压入再抬栈
    ARM寄存器支持这4种方式(2*2的组合)，即满递增(FA)、空递增(EA)、满递减(FD)、空递减(ED)。按照这种说法，x86里即满递减(FD)方式。

* 块拷贝寻址
* 相对寻址

---

# 指令格式

> IDA中显示的指令可能是多条指令合并的，NDK中也提供了反汇编工具arm-linux-androideabi-objdump，并且它是开源的，如果自己的软件中需要使用反汇编引擎时可以使用。

这里只说ARM指令集格式，THUMB指令集可使用类似方法到CPU手册中查看。

![image]({{ '/styles/images/arm/3.png' | prepend: site.baseurl }})

## 基本指令格式

ARM是三地址指令格式，指令的基本格式如下：
```
<opcode> {<cond>} {S}    <Rd>, <Rn>{, <operand2>}
```
其中<>号内的项是必须的，{}号内的项可选的。各项的说明如下：
* opcode: 指令助记符
* cond: 执行条件
* S: 是否影响CPSR寄存器的值
* Rd: 目标寄存器
* Rn: 第1个操作数的寄存器
* operand2: 第2个操作数，它有如下形式
    * #immed_8r————常数表达式，该常数必须是一个8位常数通过循环右移偶数位得到
    * Rm————寄存器方式
    * Rm, shift————寄存器移位方式，shift可能为算术右移(ASR)、逻辑左移(LSL)、逻辑右移(LSR)、循环右移(ROR)、带扩展的循环右移(RRX)

> 在ARM CPU中，寄存器移位寻址与不移位指令周期相同，这样就可以省下移位的指令周期了。因为在其中有一个桶形移位器在拿操作数时就先进行了预处理。

## 执行条件

使用条件码`cond`可以实现高效的逻辑操作，节省跳转和条件语句(不用再象x86一样为了减少跳转而想方设法的无分支)。所有的ARM指令都支持条件执行，而Thumb指令只有B指令具有条件执行功能。

操作码 | 条件助记符 | 标志 | 含义
---|---|---|---
0000 | EQ | Z=1 | 相等(EQual)
0001 | NE | Z=0 | 不相等(Not Equal)
0010 | CS/HS | C=1 | 无符号数大于等于(Carry Set)
0011 | CC/LO | C=0 | 无符号数小于(Carry Clear)
0100 | MI | N=1 | 负数(MInus)
0101 | PL | N=0 | 正数或零(PLus)
0110 | VS | V=1 | 溢出(oVerflow Set)
0111 | VC | V=0 | 没有溢出(oVerflow Clear)
1000 | HI | C=1,Z=0 | 无符号数大于(HIgher)
1001 | LS | C=0,Z=1 | 无符号数小于等于(Lower or Same)
1010 | GE | N=V | 有符号数大于等于(Greater or Equal)
1011 | LT | N!=V | 有符号数小于(Less Than)
1100 | GT | Z=0,N=V | 有符号数大于(Greater Than)
1101 | LE | Z=1,N!=V | 有符号数小于等于(Less or Equal)
1110 | AL | 任何 | 无条件指令(默认条件)(Always)
1111 | NV | 任何 | 从不指令(不要使用)(Never)